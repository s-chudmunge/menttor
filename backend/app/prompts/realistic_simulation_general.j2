You are a world-class 3D simulation engineer and physicist specializing in creating ultra-realistic, educational 3D visualizations that demonstrate real-world physics and natural phenomena. Your mission is to generate a single, complete HTML file for an interactive 3D simulation that is both scientifically accurate and visually stunning.

## User Request
**Description:** {{ description }}
**Category:** {{ category }}
**Complexity Level:** {{ complexity }}
**Interactivity:** {{ interactivity }}
**Realism Level:** {{ realism_level }}

## Component Analysis (AI-Detected)
**Primary Components:** {{ primary_components | join(', ') }}
**Required Libraries:** {{ required_libraries | join(', ') }}
**Physics Required:** {{ physics_required }}
**Molecular Structures:** {{ molecular_structures }}
**Fluid Dynamics:** {{ fluid_dynamics }}
**Electrical Systems:** {{ electrical_systems }}
**Quantum Effects:** {{ quantum_effects }}

## Universal Component System Instructions

You have access to these fundamental building blocks that can be combined to create ANY concept:

### 1. **Particle Systems** (for atoms, balls, dust, droplets, electrons)
```javascript
class UniversalParticle {
  constructor(config) {
    this.position = config.position || [0, 0, 0];
    this.velocity = config.velocity || [0, 0, 0];
    this.mass = config.mass || 1;
    this.size = config.size || 0.1;
    this.color = config.color || 0xffffff;
    this.type = config.type || 'sphere'; // sphere, cube, custom
    this.behavior = config.behavior || 'static'; // static, dynamic, oscillating, orbital
  }
}
```

### 2. **Connection Systems** (for bonds, springs, ropes, networks)
```javascript
class UniversalConnection {
  constructor(particleA, particleB, config) {
    this.particleA = particleA;
    this.particleB = particleB;
    this.strength = config.strength || 1;
    this.restLength = config.restLength || 1;
    this.type = config.type || 'spring'; // spring, rigid, flexible, attraction
    this.visible = config.visible !== false;
    this.color = config.color || 0xffffff;
  }
}
```

### 3. **Force Fields** (for gravity, magnetism, electricity, flows)
```javascript
class UniversalForceField {
  constructor(config) {
    this.type = config.type; // gravity, magnetic, electric, flow, pressure
    this.strength = config.strength || 1;
    this.direction = config.direction || [0, -1, 0];
    this.center = config.center || [0, 0, 0];
    this.range = config.range || Infinity;
    this.particles = [];
  }
}
```

### 4. **Flow Systems** (for currents, streams, circulation)
```javascript
class UniversalFlow {
  constructor(config) {
    this.path = config.path; // array of points or mathematical curve
    this.speed = config.speed || 1;
    this.particles = config.particles || [];
    this.turbulence = config.turbulence || 0;
    this.visualization = config.visualization || 'particles'; // particles, streamlines, vectorField
  }
}
```

### 5. **Structure Systems** (for frameworks, lattices, networks)
```javascript
class UniversalStructure {
  constructor(config) {
    this.type = config.type; // lattice, network, framework, surface, membrane
    this.nodes = config.nodes || [];
    this.connections = config.connections || [];
    this.constraints = config.constraints || [];
    this.deformable = config.deformable || false;
  }
}
```

## Smart Library Loading System

{% if 'cannon-es' in required_libraries %}
### Physics Engine (Cannon-es) Integration
```html
<script src="https://cdn.skypack.dev/cannon-es"></script>
<script>
// Physics World Setup
const world = new CANNON.World();
world.gravity.set(0, -9.82, 0);
world.broadphase = new CANNON.NaiveBroadphase();
world.solver.iterations = 10;
</script>
```
{% endif %}

{% if '3dmol-js' in required_libraries %}
### Molecular Visualization (3Dmol.js) Integration
```html
<script src="https://3Dmol.csb.pitt.edu/build/3Dmol-min.js"></script>
<script>
// Molecular Viewer Setup
const molecularViewer = $3Dmol.createViewer(element, {
  backgroundColor: 'black',
  antialias: true
});
</script>
```
{% endif %}

{% if 'liquidfun-js' in required_libraries %}
### Fluid Dynamics (Particle-based) Integration
```html
<script src="https://cdn.jsdelivr.net/npm/liquidfun@1.1.0/Box2D_v2.3.1_min.js"></script>
<script>
// Particle System Setup for Fluids
const particleSystem = new b2ParticleSystem();
particleSystem.SetRadius(0.1);
</script>
```
{% endif %}

## Core Technical Requirements

### Technology Stack
- **Three.js r150+**: Modern version with latest features
- **WebGL2**: Advanced rendering capabilities
- **Post-processing**: EffectComposer, UnrealBloomPass, SSAOPass
- **PBR Materials**: Realistic material properties

### HTML Structure Template
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Realistic 3D Simulation: {{ description[:50] }}</title>
    
    <!-- Core Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.150.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.150.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.9/build/dat.gui.min.js"></script>
    
    <!-- Post-processing -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.150.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.150.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.150.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.150.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.150.0/examples/js/postprocessing/ShaderPass.js"></script>
    
    <!-- Specialized Libraries Based on Requirements -->
    {% for library in required_libraries %}
    {% if library == 'cannon-es' %}
    <script src="https://cdn.skypack.dev/cannon-es"></script>
    {% elif library == '3dmol-js' %}
    <script src="https://3Dmol.csb.pitt.edu/build/3Dmol-min.js"></script>
    {% elif library == 'liquidfun-js' %}
    <script src="https://cdn.jsdelivr.net/npm/box2d-wasm@6.0.1/dist/umd/Box2D.js"></script>
    {% endif %}
    {% endfor %}
    
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000;
            color: white;
        }
        
        canvas {
            display: block;
        }
        
        #info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
            max-width: 350px;
            z-index: 100;
            transition: transform 0.3s ease;
        }
        
        #info-panel.collapsed {
            transform: translateX(-320px);
        }
        
        #toggle-info {
            position: absolute;
            top: 25px;
            right: -40px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 0 8px 8px 0;
            color: white;
            padding: 10px 8px;
            cursor: pointer;
            font-size: 16px;
            z-index: 101;
        }
        
        #performance {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 8px;
            font-size: 12px;
            font-family: monospace;
        }
        
        .dg.main {
            position: absolute !important;
            top: 20px !important;
            right: 20px !important;
            z-index: 100 !important;
        }
        
        .category-badge {
            display: inline-block;
            background: linear-gradient(45deg, #667eea 0%, #764ba2 100%);
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        @media (max-width: 768px) {
            #info-panel {
                max-width: 280px;
                font-size: 14px;
            }
            .dg.main {
                transform: scale(0.8);
                transform-origin: top right;
            }
        }
    </style>
</head>
<body>
    <div id="info-panel">
        <button id="toggle-info">‚óÄ</button>
        <div class="category-badge">{{ category.upper() }} SIMULATION</div>
        <h3>{{ description[:60] }}{% if description|length > 60 %}...{% endif %}</h3>
        
        {% if complexity == 'research' %}
        <p><strong>üî¨ Research-Grade Simulation</strong></p>
        <p>This simulation uses advanced physics engines and specialized libraries for scientific accuracy.</p>
        {% elif complexity == 'advanced' %}
        <p><strong>‚ö° Advanced Physics Simulation</strong></p>
        <p>Realistic physics with {{ required_libraries | join(', ') | replace('cannon-es', 'physics engine') | replace('3dmol-js', 'molecular viewer') }}.</p>
        {% else %}
        <p><strong>üéì Educational Simulation</strong></p>
        <p>Interactive physics demonstration with realistic behavior.</p>
        {% endif %}
        
        <hr style="border: 1px solid rgba(255,255,255,0.2); margin: 15px 0;">
        
        <p><strong>Components:</strong></p>
        <ul style="margin: 0; padding-left: 20px;">
        {% for component in primary_components %}
            <li>{{ component.replace('_', ' ').title() }}</li>
        {% endfor %}
        </ul>
        
        <p><strong>Controls:</strong></p>
        <ul style="margin: 0; padding-left: 20px; font-size: 13px;">
            <li>üñ±Ô∏è Drag to rotate view</li>
            <li>üîç Scroll to zoom</li>
            {% if physics_required %}
            <li>‚ö° Physics controls in panel ‚Üí</li>
            {% endif %}
            {% if interactivity == 'controllable' %}
            <li>üéÆ Interactive controls available</li>
            {% endif %}
        </ul>
        
        {% if realism_level == 'photorealistic' %}
        <p style="font-size: 12px; color: #888; margin-top: 15px;">
            <em>Photorealistic rendering enabled with advanced lighting and materials.</em>
        </p>
        {% endif %}
    </div>
    
    <div id="performance">
        <div>FPS: <span id="fps">--</span></div>
        <div>Particles: <span id="particle-count">--</span></div>
        {% if physics_required %}
        <div>Physics: <span id="physics-status">Active</span></div>
        {% endif %}
    </div>

    <script>
        class RealisticSimulation {
            constructor() {
                // Core Three.js setup
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ 
                    antialias: true, 
                    powerPreference: "high-performance",
                    stencil: false,
                    depth: true
                });
                
                // Enhanced renderer settings for realism
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.renderer.outputEncoding = THREE.sRGBEncoding;
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                this.renderer.toneMappingExposure = 1.0;
                
                document.body.appendChild(this.renderer.domElement);
                
                // Performance monitoring
                this.clock = new THREE.Clock();
                this.frameCount = 0;
                this.lastTime = performance.now();
                
                // Universal component arrays
                this.particles = [];
                this.connections = [];
                this.forceFields = [];
                this.flows = [];
                this.structures = [];
                
                {% if physics_required %}
                // Physics world setup
                this.world = new CANNON.World();
                this.world.gravity.set(0, -9.82, 0);
                this.world.broadphase = new CANNON.NaiveBroadphase();
                this.world.solver.iterations = 10;
                this.physicsEnabled = true;
                {% else %}
                this.physicsEnabled = false;
                {% endif %}
                
                // Control parameters
                this.params = {
                    animationSpeed: 1.0,
                    particleCount: {% if 'particles' in primary_components %}100{% else %}10{% endif %},
                    {% if physics_required %}
                    gravity: -9.82,
                    damping: 0.1,
                    {% endif %}
                    {% if 'forces' in primary_components %}
                    forceStrength: 1.0,
                    {% endif %}
                    {% if 'flows' in primary_components %}
                    flowSpeed: 1.0,
                    turbulence: 0.1,
                    {% endif %}
                    realism: {{ 1.0 if realism_level == 'photorealistic' else 0.7 if realism_level == 'realistic' else 0.5 }},
                    bloom: {{ 0.3 if realism_level == 'photorealistic' else 0.5 if realism_level == 'realistic' else 0.8 }},
                    showGrid: false,
                    autoRotate: false
                };
                
                this.init();
            }
            
            init() {
                this.setupLighting();
                this.setupControls();
                this.setupPostProcessing();
                this.setupUI();
                this.createSimulation();
                this.setupEventListeners();
                this.animate();
            }
            
            setupLighting() {
                // Advanced realistic lighting setup
                {% if realism_level == 'photorealistic' %}
                // HDRI environment (simulated)
                const pmremGenerator = new THREE.PMREMGenerator(this.renderer);
                const envMapTexture = pmremGenerator.fromEquirectangular(this.createGradientTexture());
                this.scene.environment = envMapTexture.texture;
                {% endif %}
                
                // Key light (main directional light)
                this.keyLight = new THREE.DirectionalLight(0xffffff, {{ 1.2 if realism_level == 'photorealistic' else 1.0 }});
                this.keyLight.position.set(10, 10, 5);
                this.keyLight.castShadow = true;
                this.keyLight.shadow.mapSize.width = {{ 2048 if realism_level == 'photorealistic' else 1024 }};
                this.keyLight.shadow.mapSize.height = {{ 2048 if realism_level == 'photorealistic' else 1024 }};
                this.keyLight.shadow.camera.near = 0.5;
                this.keyLight.shadow.camera.far = 500;
                this.keyLight.shadow.camera.left = -10;
                this.keyLight.shadow.camera.right = 10;
                this.keyLight.shadow.camera.top = 10;
                this.keyLight.shadow.camera.bottom = -10;
                this.scene.add(this.keyLight);
                
                // Fill light (softer, cooler)
                this.fillLight = new THREE.DirectionalLight(0x87CEEB, 0.4);
                this.fillLight.position.set(-5, 5, 2);
                this.scene.add(this.fillLight);
                
                // Rim light (back light for edge definition)
                this.rimLight = new THREE.DirectionalLight(0xffffff, 0.3);
                this.rimLight.position.set(-10, 5, -10);
                this.scene.add(this.rimLight);
                
                // Ambient light (very subtle)
                this.ambientLight = new THREE.AmbientLight(0x404040, {{ 0.2 if realism_level == 'photorealistic' else 0.4 }});
                this.scene.add(this.ambientLight);
                
                {% if not 'particles' in primary_components and not 'no_ground' %}
                // Conditional ground plane (only when contextually appropriate)
                {% if category in ['physics', 'engineering'] %}
                this.addGroundPlane();
                {% endif %}
                {% endif %}
            }
            
            addGroundPlane() {
                const groundGeometry = new THREE.PlaneGeometry(20, 20);
                const groundMaterial = new THREE.MeshStandardMaterial({
                    color: 0x333333,  // Dark to avoid bloom issues
                    metalness: 0,
                    roughness: 1.0,
                    transparent: true,
                    opacity: 0.8
                });
                
                this.ground = new THREE.Mesh(groundGeometry, groundMaterial);
                this.ground.rotation.x = -Math.PI / 2;
                this.ground.receiveShadow = true;
                this.scene.add(this.ground);
                
                {% if physics_required %}
                // Physics ground
                const groundShape = new CANNON.Plane();
                this.groundBody = new CANNON.Body({ mass: 0 });
                this.groundBody.addShape(groundShape);
                this.groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
                this.world.add(this.groundBody);
                {% endif %}
            }
            
            setupControls() {
                if (typeof THREE.OrbitControls !== 'undefined') {
                    this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                    this.controls.enableDamping = true;
                    this.controls.dampingFactor = 0.05;
                    this.controls.maxPolarAngle = Math.PI * 0.9;
                    this.controls.minDistance = 1;
                    this.controls.maxDistance = 50;
                    {% if interactivity == 'observational' %}
                    this.controls.enablePan = false;
                    this.controls.enableZoom = false;
                    {% endif %}
                } else {
                    console.warn('OrbitControls not available');
                }
            }
            
            setupPostProcessing() {
                if (typeof THREE.EffectComposer !== 'undefined' && 
                    typeof THREE.RenderPass !== 'undefined') {
                    
                    this.composer = new THREE.EffectComposer(this.renderer);
                    
                    // Render pass
                    this.renderPass = new THREE.RenderPass(this.scene, this.camera);
                    this.composer.addPass(this.renderPass);
                    
                    // Bloom effect (tuned for realism)
                    if (typeof THREE.UnrealBloomPass !== 'undefined') {
                        this.bloomPass = new THREE.UnrealBloomPass(
                            new THREE.Vector2(window.innerWidth, window.innerHeight),
                            this.params.bloom,  // strength
                            {{ 0.4 if realism_level == 'photorealistic' else 0.8 }}, // radius
                            {{ 0.3 if realism_level == 'photorealistic' else 0.1 }}  // threshold
                        );
                        this.composer.addPass(this.bloomPass);
                    }
                    
                    this.usePostProcessing = true;
                } else {
                    console.warn('Post-processing not available, using basic rendering');
                    this.usePostProcessing = false;
                }
            }
            
            setupUI() {
                // dat.GUI controls
                if (typeof dat !== 'undefined') {
                    this.gui = new dat.GUI();
                    
                    const animationFolder = this.gui.addFolder('Animation');
                    animationFolder.add(this.params, 'animationSpeed', 0, 3).name('Speed');
                    if (this.params.autoRotate !== undefined) {
                        animationFolder.add(this.params, 'autoRotate').name('Auto Rotate');
                    }
                    
                    {% if physics_required %}
                    const physicsFolder = this.gui.addFolder('Physics');
                    physicsFolder.add(this.params, 'gravity', -20, 0).name('Gravity').onChange((value) => {
                        this.world.gravity.set(0, value, 0);
                    });
                    {% endif %}
                    
                    {% if 'particles' in primary_components %}
                    const particleFolder = this.gui.addFolder('Particles');
                    particleFolder.add(this.params, 'particleCount', 10, 500).name('Count').step(10);
                    {% endif %}
                    
                    const visualFolder = this.gui.addFolder('Visual');
                    visualFolder.add(this.params, 'realism', 0, 1).name('Realism Level');
                    if (this.bloomPass) {
                        visualFolder.add(this.params, 'bloom', 0, 2).name('Bloom').onChange((value) => {
                            this.bloomPass.strength = value;
                        });
                    }
                    if (this.ground) {
                        visualFolder.add(this.params, 'showGrid').name('Show Grid');
                    }
                    
                    // Start with folders closed for mobile
                    if (window.innerWidth < 768) {
                        animationFolder.close();
                        {% if physics_required %}physicsFolder.close();{% endif %}
                        visualFolder.close();
                    }
                } else {
                    console.warn('dat.GUI not available');
                }
                
                // Info panel toggle
                const infoPanel = document.getElementById('info-panel');
                const toggleBtn = document.getElementById('toggle-info');
                if (toggleBtn && infoPanel) {
                    toggleBtn.addEventListener('click', () => {
                        infoPanel.classList.toggle('collapsed');
                        toggleBtn.innerHTML = infoPanel.classList.contains('collapsed') ? '‚ñ∂' : '‚óÄ';
                    });
                }
            }
            
            createSimulation() {
                // This is where the AI will create the specific simulation
                // based on the detected components and user description
                
                {% if fallback_strategy == 'procedural_abstract' %}
                this.createAbstractVisualization();
                {% else %}
                this.createComponentBasedSimulation();
                {% endif %}
                
                // Position camera based on simulation content
                this.camera.position.set(5, 5, 5);
                this.camera.lookAt(0, 0, 0);
            }
            
            createComponentBasedSimulation() {
                // Create simulation based on detected components
                {% for component in primary_components %}
                {% if component == 'particles' %}
                this.createParticleSystem();
                {% elif component == 'connections' %}
                this.createConnectionSystem();
                {% elif component == 'forces' %}
                this.createForceField();
                {% elif component == 'flows' %}
                this.createFlowSystem();
                {% elif component == 'structures' %}
                this.createStructuralSystem();
                {% elif component == 'oscillations' %}
                this.createOscillationSystem();
                {% elif component == 'rotations' %}
                this.createRotationalSystem();
                {% endif %}
                {% endfor %}
                
                {% if not primary_components %}
                // Fallback: create basic representation
                this.createBasicRepresentation();
                {% endif %}
            }
            
            createParticleSystem() {
                // Universal particle system that adapts to context
                const particleCount = this.params.particleCount || 50;
                const geometry = new THREE.SphereGeometry(0.05, 8, 8);
                
                {% if molecular_structures %}
                // Molecular particle appearance
                const material = new THREE.MeshStandardMaterial({
                    color: 0x4CAF50,
                    metalness: 0.1,
                    roughness: 0.8,
                    emissive: 0x001100
                });
                {% elif physics_required %}
                // Physics particle appearance
                const material = new THREE.MeshStandardMaterial({
                    color: 0x2196F3,
                    metalness: 0.3,
                    roughness: 0.4
                });
                {% else %}
                // General particle appearance
                const material = new THREE.MeshStandardMaterial({
                    color: 0xFF9800,
                    metalness: 0.2,
                    roughness: 0.6
                });
                {% endif %}
                
                for (let i = 0; i < particleCount; i++) {
                    const particle = new THREE.Mesh(geometry, material.clone());
                    
                    // Position particles based on context
                    {% if molecular_structures %}
                    // Molecular arrangement
                    particle.position.set(
                        (Math.random() - 0.5) * 4,
                        (Math.random() - 0.5) * 4,
                        (Math.random() - 0.5) * 4
                    );
                    {% else %}
                    // Physics or general arrangement
                    particle.position.set(
                        (Math.random() - 0.5) * 10,
                        Math.random() * 8 + 2,
                        (Math.random() - 0.5) * 10
                    );
                    {% endif %}
                    
                    particle.castShadow = true;
                    particle.receiveShadow = true;
                    this.scene.add(particle);
                    this.particles.push(particle);
                    
                    {% if physics_required %}
                    // Add physics body
                    const shape = new CANNON.Sphere(0.05);
                    const body = new CANNON.Body({ mass: 1 });
                    body.addShape(shape);
                    body.position.set(particle.position.x, particle.position.y, particle.position.z);
                    this.world.add(body);
                    particle.userData = { physicsBody: body };
                    {% endif %}
                }
            }
            
            createFlowSystem() {
                // Universal flow system for fluid dynamics, currents, streams
                const flowParticleCount = 100;
                const flowGeometry = new THREE.SphereGeometry(0.02, 6, 6);
                
                {% if fluid_dynamics %}
                // Fluid particle appearance
                const flowMaterial = new THREE.MeshStandardMaterial({
                    color: 0x00BFFF,
                    metalness: 0.1,
                    roughness: 0.9,
                    transparent: true,
                    opacity: 0.7
                });
                {% else %}
                // General flow appearance
                const flowMaterial = new THREE.MeshStandardMaterial({
                    color: 0x00CED1,
                    metalness: 0.2,
                    roughness: 0.6,
                    transparent: true,
                    opacity: 0.8
                });
                {% endif %}
                
                // Create flow path - circular for demo
                const flowRadius = 3;
                for (let i = 0; i < flowParticleCount; i++) {
                    const flowParticle = new THREE.Mesh(flowGeometry, flowMaterial.clone());
                    
                    const angle = (i / flowParticleCount) * Math.PI * 2;
                    flowParticle.position.set(
                        Math.cos(angle) * flowRadius,
                        Math.sin(angle * 0.5) * 0.5,
                        Math.sin(angle) * flowRadius
                    );
                    
                    flowParticle.castShadow = true;
                    this.scene.add(flowParticle);
                    this.particles.push(flowParticle);
                    
                    // Store flow properties
                    flowParticle.userData = {
                        flowIndex: i,
                        flowAngle: angle,
                        flowSpeed: 0.01 + Math.random() * 0.02
                    };
                }
                
                // Add flow lines for visualization
                const flowLineGeometry = new THREE.BufferGeometry();
                const flowLinePositions = [];
                for (let i = 0; i <= 100; i++) {
                    const angle = (i / 100) * Math.PI * 2;
                    flowLinePositions.push(
                        Math.cos(angle) * flowRadius,
                        Math.sin(angle * 0.5) * 0.5,
                        Math.sin(angle) * flowRadius
                    );
                }
                flowLineGeometry.setAttribute('position', new THREE.Float32BufferAttribute(flowLinePositions, 3));
                
                const flowLineMaterial = new THREE.LineBasicMaterial({
                    color: 0x00CED1,
                    transparent: true,
                    opacity: 0.3
                });
                
                const flowLine = new THREE.Line(flowLineGeometry, flowLineMaterial);
                this.scene.add(flowLine);
                this.flows.push(flowLine);
            }
            
            createConnectionSystem() {
                // Universal connection system for bonds, springs, networks
                if (this.particles.length < 2) {
                    // Create some base particles if none exist
                    this.createParticleSystem();
                }
                
                const connectionMaterial = new THREE.LineBasicMaterial({
                    color: 0xFFD700,
                    transparent: true,
                    opacity: 0.6
                });
                
                // Connect nearby particles
                for (let i = 0; i < this.particles.length; i++) {
                    for (let j = i + 1; j < Math.min(i + 3, this.particles.length); j++) {
                        const geometry = new THREE.BufferGeometry();
                        const positions = [
                            this.particles[i].position.x, this.particles[i].position.y, this.particles[i].position.z,
                            this.particles[j].position.x, this.particles[j].position.y, this.particles[j].position.z
                        ];
                        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                        
                        const connection = new THREE.Line(geometry, connectionMaterial);
                        this.scene.add(connection);
                        this.connections.push(connection);
                    }
                }
            }
            
            createForceField() {
                // Universal force field visualization
                const forceVisualization = new THREE.Group();
                
                // Create force field indicators
                for (let i = 0; i < 20; i++) {
                    const arrowGeometry = new THREE.ConeGeometry(0.05, 0.3, 8);
                    const arrowMaterial = new THREE.MeshStandardMaterial({
                        color: 0xFF4500,
                        emissive: 0x220000
                    });
                    
                    const arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
                    const angle = (i / 20) * Math.PI * 2;
                    arrow.position.set(
                        Math.cos(angle) * 4,
                        Math.random() * 2 - 1,
                        Math.sin(angle) * 4
                    );
                    arrow.lookAt(0, 0, 0);
                    arrow.castShadow = true;
                    
                    forceVisualization.add(arrow);
                }
                
                this.scene.add(forceVisualization);
                this.forceFields.push(forceVisualization);
            }
            
            createStructuralSystem() {
                // Universal structural system for lattices, frameworks
                const structureGroup = new THREE.Group();
                
                // Create a simple lattice structure
                const nodeMaterial = new THREE.MeshStandardMaterial({
                    color: 0x8A2BE2,
                    metalness: 0.3,
                    roughness: 0.4
                });
                
                const beamMaterial = new THREE.MeshStandardMaterial({
                    color: 0x696969,
                    metalness: 0.7,
                    roughness: 0.3
                });
                
                // Create nodes
                const nodes = [];
                for (let x = -2; x <= 2; x += 2) {
                    for (let y = -1; y <= 1; y += 2) {
                        for (let z = -2; z <= 2; z += 2) {
                            const nodeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                            const node = new THREE.Mesh(nodeGeometry, nodeMaterial);
                            node.position.set(x, y, z);
                            node.castShadow = true;
                            structureGroup.add(node);
                            nodes.push(node);
                        }
                    }
                }
                
                // Connect nodes with beams
                for (let i = 0; i < nodes.length; i++) {
                    for (let j = i + 1; j < nodes.length; j++) {
                        const distance = nodes[i].position.distanceTo(nodes[j].position);
                        if (distance <= 2.1) { // Only connect nearby nodes
                            const beamGeometry = new THREE.CylinderGeometry(0.02, 0.02, distance);
                            const beam = new THREE.Mesh(beamGeometry, beamMaterial);
                            
                            beam.position.copy(nodes[i].position).lerp(nodes[j].position, 0.5);
                            beam.lookAt(nodes[j].position);
                            beam.rotateX(Math.PI / 2);
                            beam.castShadow = true;
                            
                            structureGroup.add(beam);
                        }
                    }
                }
                
                this.scene.add(structureGroup);
                this.structures.push(structureGroup);
            }
            
            createOscillationSystem() {
                // Create oscillating elements
                if (this.particles.length === 0) {
                    this.createParticleSystem();
                }
                
                // Set oscillation properties for particles
                this.particles.forEach((particle, index) => {
                    particle.userData.oscillation = {
                        amplitude: 0.5 + Math.random() * 0.5,
                        frequency: 1 + Math.random() * 2,
                        phase: Math.random() * Math.PI * 2,
                        axis: Math.random() < 0.5 ? 'y' : 'x'
                    };
                });
            }
            
            createRotationalSystem() {
                // Create rotating elements
                if (this.particles.length === 0) {
                    this.createParticleSystem();
                }
                
                // Set rotation properties for particles
                this.particles.forEach((particle, index) => {
                    particle.userData.rotation = {
                        speed: 0.5 + Math.random() * 2,
                        axis: new THREE.Vector3(
                            Math.random() - 0.5,
                            Math.random() - 0.5,
                            Math.random() - 0.5
                        ).normalize()
                    };
                });
            }
            
            createBasicRepresentation() {
                // Fallback: create basic geometric representation
                const geometry = new THREE.BoxGeometry(1, 1, 1);
                const material = new THREE.MeshStandardMaterial({
                    color: 0x666666,
                    metalness: 0.3,
                    roughness: 0.7
                });
                
                const basicObject = new THREE.Mesh(geometry, material);
                basicObject.castShadow = true;
                basicObject.receiveShadow = true;
                this.scene.add(basicObject);
                
                this.particles.push(basicObject);
            }
            
            createAbstractVisualization() {
                // For unknown concepts, create abstract geometric representation
                const geometry = new THREE.IcosahedronGeometry(1, 2);
                const material = new THREE.MeshStandardMaterial({
                    color: 0x9C27B0,
                    metalness: 0.4,
                    roughness: 0.6,
                    transparent: true,
                    opacity: 0.8
                });
                
                const abstractForm = new THREE.Mesh(geometry, material);
                abstractForm.castShadow = true;
                abstractForm.receiveShadow = true;
                this.scene.add(abstractForm);
                
                // Add some procedural detail
                for (let i = 0; i < 20; i++) {
                    const smallGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                    const smallMaterial = new THREE.MeshStandardMaterial({
                        color: new THREE.Color().setHSL(i / 20, 0.7, 0.5),
                        metalness: 0.2,
                        roughness: 0.8
                    });
                    
                    const smallSphere = new THREE.Mesh(smallGeometry, smallMaterial);
                    const angle = (i / 20) * Math.PI * 2;
                    smallSphere.position.set(
                        Math.cos(angle) * 2,
                        Math.sin(angle * 2) * 0.5,
                        Math.sin(angle) * 2
                    );
                    smallSphere.castShadow = true;
                    this.scene.add(smallSphere);
                    this.particles.push(smallSphere);
                }
                
                this.abstractForm = abstractForm;
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                const deltaTime = this.clock.getDelta() * this.params.animationSpeed;
                
                {% if physics_required %}
                // Update physics
                if (this.physicsEnabled && this.world) {
                    this.world.step(1/60, deltaTime, 3);
                    
                    // Sync visual objects with physics
                    this.particles.forEach(particle => {
                        if (particle.userData && particle.userData.physicsBody) {
                            particle.position.copy(particle.userData.physicsBody.position);
                            particle.quaternion.copy(particle.userData.physicsBody.quaternion);
                        }
                    });
                }
                {% endif %}
                
                // Update visual animations
                this.updateAnimations(deltaTime);
                
                // Update controls
                if (this.controls) this.controls.update();
                
                // Update performance stats
                this.updatePerformanceStats();
                
                // Render
                if (this.usePostProcessing && this.composer) {
                    this.composer.render();
                } else {
                    this.renderer.render(this.scene, this.camera);
                }
            }
            
            updateAnimations(deltaTime) {
                const time = this.clock.getElapsedTime();
                
                // Abstract form rotation
                if (this.abstractForm) {
                    this.abstractForm.rotation.x += 0.5 * deltaTime;
                    this.abstractForm.rotation.y += 0.3 * deltaTime;
                }
                
                // Auto-rotate camera if enabled
                if (this.params.autoRotate && this.controls) {
                    this.controls.autoRotate = true;
                    this.controls.autoRotateSpeed = 0.5;
                } else if (this.controls) {
                    this.controls.autoRotate = false;
                }
                
                // Update particle animations based on their userData
                this.particles.forEach((particle, index) => {
                    // Flow animations
                    if (particle.userData && particle.userData.flowAngle !== undefined) {
                        const flowSpeed = this.params.flowSpeed || 1.0;
                        const newAngle = particle.userData.flowAngle + time * particle.userData.flowSpeed * flowSpeed;
                        const flowRadius = 3;
                        particle.position.set(
                            Math.cos(newAngle) * flowRadius,
                            Math.sin(newAngle * 0.5) * 0.5,
                            Math.sin(newAngle) * flowRadius
                        );
                    }
                    
                    // Oscillation animations
                    if (particle.userData && particle.userData.oscillation) {
                        const osc = particle.userData.oscillation;
                        const oscillationValue = Math.sin(time * osc.frequency + osc.phase) * osc.amplitude;
                        if (osc.axis === 'y') {
                            particle.position.y += oscillationValue * deltaTime;
                        } else {
                            particle.position.x += oscillationValue * deltaTime;
                        }
                    }
                    
                    // Rotation animations
                    if (particle.userData && particle.userData.rotation) {
                        const rot = particle.userData.rotation;
                        particle.rotateOnAxis(rot.axis, rot.speed * deltaTime);
                    }
                });
                
                // Custom animations based on components
                {% for component in primary_components %}
                {% if component == 'oscillations' %}
                // Additional oscillating motion for components without userData
                this.particles.forEach((particle, index) => {
                    if (!particle.userData || !particle.userData.oscillation) {
                        particle.position.y += Math.sin(time * 2 + index * 0.5) * 0.01;
                    }
                });
                {% elif component == 'rotations' %}
                // Additional rotational motion for components without userData
                this.particles.forEach((particle, index) => {
                    if (!particle.userData || !particle.userData.rotation) {
                        particle.rotation.y += deltaTime * (1 + index * 0.1);
                    }
                });
                {% elif component == 'flows' %}
                // Additional flow motion for components without userData
                this.particles.forEach((particle, index) => {
                    if (!particle.userData || particle.userData.flowAngle === undefined) {
                        const flowSpeed = this.params.flowSpeed || 1.0;
                        particle.position.x += Math.sin(time * flowSpeed + index) * 0.01;
                        particle.position.z += Math.cos(time * flowSpeed + index) * 0.01;
                    }
                });
                {% endif %}
                {% endfor %}
                
                // Update connections to follow particles
                this.connections.forEach((connection, index) => {
                    if (index * 2 + 1 < this.particles.length) {
                        const particleA = this.particles[index * 2];
                        const particleB = this.particles[index * 2 + 1];
                        if (particleA && particleB && connection.geometry) {
                            const positions = connection.geometry.attributes.position.array;
                            positions[0] = particleA.position.x;
                            positions[1] = particleA.position.y;
                            positions[2] = particleA.position.z;
                            positions[3] = particleB.position.x;
                            positions[4] = particleB.position.y;
                            positions[5] = particleB.position.z;
                            connection.geometry.attributes.position.needsUpdate = true;
                        }
                    }
                });
            }
            
            updatePerformanceStats() {
                this.frameCount++;
                const now = performance.now();
                
                if (now - this.lastTime >= 1000) {
                    const fps = Math.round((this.frameCount * 1000) / (now - this.lastTime));
                    document.getElementById('fps').textContent = fps;
                    document.getElementById('particle-count').textContent = this.particles.length;
                    
                    this.frameCount = 0;
                    this.lastTime = now;
                    
                    // Performance warnings
                    if (fps < 30) {
                        console.warn('Low FPS detected:', fps);
                    }
                }
            }
            
            setupEventListeners() {
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                    
                    if (this.composer) {
                        this.composer.setSize(window.innerWidth, window.innerHeight);
                    }
                });
                
                // Keyboard controls for advanced interaction
                {% if interactivity == 'controllable' %}
                document.addEventListener('keydown', (event) => {
                    switch(event.key) {
                        case ' ':
                            // Spacebar: pause/resume physics
                            {% if physics_required %}
                            this.physicsEnabled = !this.physicsEnabled;
                            document.getElementById('physics-status').textContent = 
                                this.physicsEnabled ? 'Active' : 'Paused';
                            {% endif %}
                            event.preventDefault();
                            break;
                        case 'r':
                            // R key: reset simulation
                            this.resetSimulation();
                            break;
                    }
                });
                {% endif %}
            }
            
            resetSimulation() {
                // Reset all particles and physics bodies
                {% if physics_required %}
                this.particles.forEach(particle => {
                    if (particle.userData && particle.userData.physicsBody) {
                        particle.userData.physicsBody.position.set(
                            (Math.random() - 0.5) * 10,
                            Math.random() * 8 + 2,
                            (Math.random() - 0.5) * 10
                        );
                        particle.userData.physicsBody.velocity.set(0, 0, 0);
                        particle.userData.physicsBody.angularVelocity.set(0, 0, 0);
                    }
                });
                {% endif %}
                
                console.log('Simulation reset');
            }
            
            createGradientTexture() {
                // Create a simple gradient texture for environment mapping
                const size = 512;
                const canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                const context = canvas.getContext('2d');
                
                const gradient = context.createRadialGradient(
                    size/2, size/2, 0, 
                    size/2, size/2, size/2
                );
                gradient.addColorStop(0, '#87CEEB');
                gradient.addColorStop(1, '#191970');
                
                context.fillStyle = gradient;
                context.fillRect(0, 0, size, size);
                
                const texture = new THREE.CanvasTexture(canvas);
                texture.mapping = THREE.EquirectangularReflectionMapping;
                return texture;
            }
        }
        
        // Initialize the simulation when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            // Check for required dependencies
            if (typeof THREE === 'undefined') {
                document.body.innerHTML = `
                    <div style="display: flex; justify-content: center; align-items: center; height: 100vh; background: #000; color: #fff; font-family: Arial; text-align: center;">
                        <div>
                            <h2>‚ö†Ô∏è Loading Error</h2>
                            <p>Three.js library failed to load. Please check your internet connection.</p>
                        </div>
                    </div>
                `;
                return;
            }
            
            try {
                const simulation = new RealisticSimulation();
                window.simulation = simulation; // For debugging
            } catch (error) {
                console.error('Failed to initialize simulation:', error);
                document.body.innerHTML = `
                    <div style="display: flex; justify-content: center; align-items: center; height: 100vh; background: #000; color: #fff; font-family: Arial; text-align: center;">
                        <div>
                            <h2>üîß Initialization Error</h2>
                            <p>Failed to start the realistic simulation.</p>
                            <p style="font-size: 12px; color: #888;">Error: ${error.message}</p>
                        </div>
                    </div>
                `;
            }
        });
    </script>
</body>
</html>
```

## CRITICAL INSTRUCTIONS

1. **Component Analysis**: Use the provided component analysis to determine exactly which libraries and features to include
2. **Library Conditional Loading**: Only load libraries that are actually needed based on the analysis
3. **Universal Components**: Build the simulation using the universal component system (particles, connections, forces, flows, structures)
4. **Realistic Materials**: Use PBR materials with appropriate metalness, roughness, and color values
5. **Performance Optimization**: Include performance monitoring and adaptive quality settings
6. **Mobile Responsiveness**: Ensure the interface works on mobile devices
7. **Error Handling**: Include comprehensive error handling and fallbacks
8. **Educational Value**: Make the simulation educational with clear explanations and controls

## Expected Output

Generate a complete, single HTML file that creates a scientifically accurate, visually stunning, and educationally valuable 3D simulation of the requested concept using the most appropriate combination of the available libraries and universal components.

The simulation should be:
- **Scientifically accurate** with realistic physics where applicable
- **Visually impressive** with professional lighting and materials  
- **Educationally valuable** with clear explanations and interactive controls
- **Performance optimized** for various devices
- **Robust** with proper error handling and fallbacks